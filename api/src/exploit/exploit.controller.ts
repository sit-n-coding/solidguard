import {
  BadRequestException,
  Body,
  Controller,
  Get,
  NotFoundException,
  Param,
  Post,
  Patch,
  Query,
  UseGuards,
} from '@nestjs/common';
import { ExploitService } from './exploit.service';
import {
  CreateExploitRequestDto,
  SearchExploitsResponseDto,
  ExploitResponseDto,
  SearchExploitsQueryDto,
  CreateExploitResponseDto,
  ExploitIdParamDto,
} from './dto';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { RolesGuard } from '../user/guard/roles.guard';
import { Roles } from '../user/guard/roles.decorator';
import { Role } from '@prisma/client';
import {
  ApiBadRequestResponse,
  ApiConflictResponse,
  ApiCreatedResponse,
  ApiForbiddenResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiTags,
} from '@nestjs/swagger';
import { SessionAuthGuard } from '../user/guard/session-auth.guard';
import { ContractService } from '../contract/contract.service';
import { UserId } from '../user/guard/user-id.decorator';
import { TransformPlainToClass } from 'class-transformer';
import { UserService } from '../user/user.service';
import validator from 'validator';

@ApiTags('exploit')
@Controller('exploit')
export class ExploitController {
  constructor(
    @InjectQueue('exploitNotify')
    private readonly exploitNotifyQueue: Queue,
    private readonly exploitService: ExploitService,
    private readonly contractService: ContractService,
    private readonly userService: UserService
  ) {}

  @Get('id/:exploitId')
  @ApiParam({ name: 'exploitId', type: String })
  @ApiOperation({ summary: 'Gets exploit by exploitId.' })
  @ApiOkResponse({
    description: 'Returns the exploit by exploitId',
    type: ExploitResponseDto,
  })
  @ApiNotFoundResponse({
    description: 'The exploit with the given exploitId does not exist.',
  })
  @TransformPlainToClass(ExploitResponseDto)
  public async getExploitById(
    @Param('exploitId') params: ExploitIdParamDto
  ): Promise<ExploitResponseDto> {
    const exploit = await this.exploitService.getExploit(params.exploitId);
    if (!exploit) {
      throw new NotFoundException('Exploit at the given id does not exist.');
    }
    const user = await this.userService.getUserById(exploit.authorUserId);
    return { ...exploit, authorName: user.name };
  }

  @Get('search/:page')
  @ApiParam({ name: 'page', type: Number, example: 1 })
  @ApiQuery({ type: SearchExploitsQueryDto })
  @ApiOperation({ summary: 'Searches for the exploit by the name query.' })
  @ApiOkResponse({
    description: 'Returns exploits matching the search query.',
    type: SearchExploitsResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Page number must be >= 1.',
  })
  @ApiNotFoundResponse({
    description: 'There are no exploits that matches the given query.',
  })
  @TransformPlainToClass(SearchExploitsResponseDto)
  public async searchExploitByName(
    @Param('page') pageNo: number,
    @Query() queryInfo: SearchExploitsQueryDto
  ): Promise<SearchExploitsResponseDto> {
    const searchDto = {
      name: queryInfo.name ? queryInfo.name : '',
      pageNo,
    };
    if (searchDto.pageNo < 1) {
      throw new BadRequestException('Page must be >= 1.');
    }

    const exploits = await this.exploitService.searchExploitByName(searchDto);
    const exploitsDisplay: ExploitResponseDto[] = [];

    // map authorUserId -> exploits

    // merge authorNames with exploits
    for (let i = 0; i < exploits.length; i++) {
      const user = await this.userService.getUserById(exploits[i].authorUserId);
      exploitsDisplay[i] = { ...exploits[i], authorName: user.name };
    }
    const c = {
      data: exploitsDisplay,
    };

    if (!exploitsDisplay) {
      throw new NotFoundException({
        errorMessage: 'Cannot find any exploits with the given query.',
        data: [],
      });
    }

    return c;
  }

  @Get('/:page')
  @ApiParam({ name: 'page', type: Number })
  @ApiOperation({ summary: 'Gets exploit by userId.' })
  @ApiCreatedResponse({
    description: 'Returns the user exploit.',
    type: ExploitResponseDto,
  })
  @ApiForbiddenResponse({
    description: "Signer's address does not match with the deployer's address.",
  })
  @UseGuards(SessionAuthGuard)
  public async getUserExploit(
    @UserId() userId: string,
    @Param('page') page: number
  ): Promise<ExploitResponseDto[]> {
    if (page < 0) {
      throw new BadRequestException('Page must be >= 0.');
    }

    const exploits = await this.exploitService.getUserExploit(userId, page);
    const exploitsDisplay: ExploitResponseDto[] = [];
    const user = await this.userService.getUserById(exploits[0].authorUserId);
    for (let i = 0; i < exploits.length; i++) {
      exploitsDisplay[i] = { ...exploits[i], authorName: user.name };
    }

    return exploitsDisplay;
  }

  @Post()
  @ApiOperation({ summary: 'Creates a new exploit.' })
  @ApiCreatedResponse({
    description:
      'Created a new exploit on the database, and has returned the exploit that has just been added',
    type: CreateExploitResponseDto,
  })
  @ApiConflictResponse({
    description: 'There already exists an exploit with the same name.',
  })
  @UseGuards(SessionAuthGuard)
  public async createExploit(
    @UserId() userId: string,
    @Body() createExploitRequestDto: CreateExploitRequestDto
  ): Promise<CreateExploitResponseDto> {
    const esInfo = {
      names: createExploitRequestDto.targetNames,
      addr: createExploitRequestDto.targetAddr,
    };

    // escape characters used for SQL injection
    const reqEscaped = {
      ...createExploitRequestDto,
      description: validator.escape(createExploitRequestDto.description),
    };

    // check if they are valid etherscan contracts
    if (!(await this.contractService.isValidEtherscanContracts(esInfo)))
      throw new BadRequestException('Not a valid smart contract target.');
    const createExploit = { ...reqEscaped, authorUserId: userId };
    return this.exploitService.createExploit(createExploit);
  }

  @Patch('verify/:exploitId')
  @UseGuards(SessionAuthGuard, RolesGuard)
  @Roles(Role.ADMIN)
  @ApiOperation({
    summary:
      'Verifies the exploit by their exploitId, and creates a job to notify/pause managers of the smart contracts that have this exploit.',
  })
  @ApiCreatedResponse({ description: 'Added to queue for verification.' })
  public async verifyexploit(@Param('exploitId') params: ExploitIdParamDto) {
    await this.exploitService.verifyExploit(params.exploitId);
    await this.exploitNotifyQueue.add({ exploitId: params.exploitId });
  }
}
